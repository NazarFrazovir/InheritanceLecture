#include <iostream>
#include "Array.h"

                                       // Наслідування (Inheritance)

/*
    Наслідування - Один із основних принципів ООП

* Надає можливість створити нові класи на базі інсуючих
* Дозволяє перевикористання коду уникаючи його дублювання
* Надає можливість модифікувати поведінку існуючих класів у нових
* Буває Single inheritance or Multiple inheritance
*/


/* 1. Згадуємо інкапсуляцію.

Інкапсуляція - це концепція ООП, яка дозволяє обʼєднувати дані та методи їх обробки в одну
єдину сутність, яка називається класом або строктурою і захищати їх від зовнішнього втручання
завдяки модифікаторам доступу(privat,protected).
*/

/* 2. Що таке насідування?
Наслідування це концепція ООП яка дозволяє створювати нові класи на основі уже існуючих.
*/

/* 3. Реалізація Наслідуванняю
Синтаксис наслідування:

class Імʼя_Дочірнього_Класу : Модифікатор_Наслідування Імʼя_Батьківського_Класу
{
    Реалізація класу
}
*/
// -- Дочірній клас - це клас, який наслідує
// -- Батьківський клас - це клас від якого наслідується

/* 4. Модифікатор доступу protected
    Модифікатор доступу protected означає що елемменти можуть бути доступні з:

- Самим класом, в якому вони визначені.
- Похідини класами(у тому числі і через їхні обʼєкти)
*/

/* 5. Наслідування і конструктори

- Конструктор за замовчуванням: Створюється за необхідності в дочірньому класі, якщо в батьківському класі
він не був визначений явно. У цьому випадку при створені обʼєкта похідного класу, буде створений конструктор
батьківського класу,якщо він доступний.

- Конструктор батьківського класу має викликатися першим, а конструктор дочірнього класу, викликається після нього.
Це все відбувається завдяки списку ініціалізації.

- Деструктор, не наслідується, і викликається наоборот, спочатку викликається деструктор дочірнього класу,
потім деструктор батьківського класу.

- Конструктор копіювання: Copy constructor також може бути успадкований в дочірньому класі. У цьому випадку
обʼєкти дочірнього класу можуть бути скопійовані з обʼєктів базового класу з Copy constructor базового класу.
(Так само із move constructor)

*/



// struct Point{

// };

// class Person{};

// class Vehicle{
//     protected:
// Point position;
// double height;
// double lenght;
// double width;
// double weight;
//     public:
// void Move(Point direction);
// void Rotate(Point direction);
// void Scale(float factor);
// };

// class Car:public Vehicle
// {
//     private:
// int doors;
// int tankCapacity;
// char model[30];
// char mark[30];
// bool isStarted;

//     public:
// void FillUp(int points);
// void Start();
// };

// class Plane:public Vehicle
// {
//     private:
// int seets;
// Point route[2];

//     public:
// void AutorizePeople(const Person* peoplelist);
// void Fly();
// void CallDispatcher(Person dispatcher);
// };

int main(){

// Car car1;
// car1.FillUp(10);

// car1.Scale(10); // Тепер ми наслідуємо метод Scale із класса Vehicle
Array arr1(25);
    return 0;
}
